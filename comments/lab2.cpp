#include <iostream>

using namespace std;

/*
	Comments :)
	I couldn't understand the exact task, 
	but I think it would be easy to edit 
	this code for your purposes
*/

class myFun // Это и есть, сосбсна наш класс (определение в теории второй лабы в начале дано, там изи)
{  // Но мы рассмотрим немного то, что у нас есть
private: // приватная секция (вообще, в классе по умолчанию поля (методы и переменные) являются приватными)
         // но тут я явно указал (так красивше)
	double x, y, z; // описываем переменные. Приватные - значит, что доступ к ним имеют только методы внутри класса
	double result; // то есть, мы не можем где-нибудь в main() написать:
	/*
		myFun kek();
		cout << kek.x << endl;
		
		Это выдаст ошибку. х - приватная переменная.
	*/
public: // а вот теперь уже пошли публичные переменные и методы (в нашем случае - только методы)
	// к ним уже мы можем обращаться, как я показал в примере выше
	void set(double, double, double); // прототип функции (метода) установки значений переменных
	/*
		Такая функция нам нужна, как ты понимаешь, чтобы задать значения. Мы ведь не можем напрямую указать
		kek.x = 5; так как кек - приватная переменная. Но мы можем вызвать метод kek.set(12, 15, 13); Он уже публичный
		и он имеет права доступа к приватным переменным.
	*/
	void print(); // прототип метода вывода значений на экран
	void run(); // прототип метода выполнения задания
};
.
/*
	Итак, мы описали класс. Но у методов пока что есть только прототипы.
	Мы можем вообще-то и код методов писать прямо в классе, но обычно это дело разделяют,
	к тому же, у тебя в задании так и сказано - код отдельно :)

*/


/*
	Такс, операция :: - это обращение к области видимости или что-то такое.
	В любом случае, суть следующая. У тебя есть класс myFun, в нём какие-то функции.
	Тебе нужно описать сами эти функции. И т.к. это не просто функция, а метод класса,
	нужно это указать, поэтому пишется myFun::methodName;

	Поехали
*/
void myFun::set(double x, double y, double z) // описание метода установки значений
{
	/*
		this - указатель на конкретный объект класса, у которого вызвана функция.
		Как бы, ссылаемся сами на себя. В нашем случае это нужно, чтобы отличить 
		переменные х, у, z - поля класса и одноимённые переменные - аргументы функции.
		Если такой неоднозначности у нас вдруг нет, обращение к указателю this можно опустить.
	*/
	this->x = x; // Просто задаём значения переменным.
	this->y = y; // Напомню немного. Операция * - это разыменование указателя. Например, если у нас есть int *x = &y;, то есть
	this->z = z; // указатель на память, где лежит у, то операция *x вернёт нам собственно этот int.
	// Здесь же я использую операцию ->, которая заменяет собой операции разыменования указателя и обращения к полю класса, то есть
	// myFun *pointerToClass = new myFun();
	// (*pointerToClass).print();    вот эта вот
	// pointerToClass->print();      и вот эта вот записи аналогичны.
}

void myFun::print() // метод вывода результата, нечего объяснять
{
	cout << "phi = " << result << endl;
}

void myFun::run() // выполняю индивидуальное задание
{
	/*	
		там нужно было формулу посчитать. Тут эти действия и записаны.
		Почему так назвал переменные? numerator - числитель, denominator - знаменатель

		используются функции:
		exp(x);       ---  экспонента (е в степени х) 
		pow(x, y);    ---  возведение в степень, т.е. х в степени у
		atan(x);      ---  арктангенс х
		cbrt(x);      ---  кубический корень х (cube root)
		log(x);       ---  натуральный логарифм (по основанию е)
	*/
	double numerator = exp(abs(x - y)) * pow(abs(x - y), x + y);
	double denominator = atan(x) + atan(z);
	double radical = cbrt(pow(x, 6) + pow(log(y), 2));
	result = numerator / denominator + radical;
}

int main()
{
	cout << "\t\t *** Direct ***\n\n"; 
	myFun direct; // Объявляю объект просто
	direct.set(-2.235 * 0.01, 2.23, 15.221); // и просто обращаюсь к полям объекта
	direct.run();                            // в методе это названо "прямым" вызовом
	direct.print();
	cout << "\n\n";

	cout << "\t\t*** Indirect ***\n\n";
	myFun *indirect = new myFun;    // Объявляю указатель, выделяю память под новый объект типа myFun, инициализирую указатель этой памятью
	indirect->set(-2.235 * 0.01, 2.23, 15.221); // и обращаюсь к полям, разыменовывая сначала указатель
	indirect->run();                            // в методе это названо "косвенным" вызовом
	indirect->print();
	delete indirect;  // не забываю очистить память (иначе утечка)
	system("pause"); // чтобы на винде не закрывалось потом окошко (в вижле например)
	return 0;
}