#include <iostream>

using namespace std;

/*
	Итак, пару слов об этой лабе. 
	Задание здесь такое же, как и в прошлой (2) лабе, но растянуть всё это теперь нужно на целых 2 класса.
	Честно говоря, это просто бесполезное извращение, но, вроде, сделано всё как надо.
	Давай разбираться.
*/

class Y; // сразу скажем, что у нас будет класс У, т.к. потом нужно будет указать тип аргумента этим классом.
   .     // я покажу

class X // Описываем класс Х
{
private: // приватные переменные
	double x, y; 
	double result;
public: // публичные
	X(double, double); // конструктор, который принимает два вещественных числа. Что такое конструктор - написано в методе
	                   // если коротко, то когда мы создаём новый объект, то он выполниться. Один раз.
	friend void print(X*); // дружественные функции - этому и посвящена лаба. Если коротко, то они не являются методами класса,
	friend void run(X*, Y*); // а являются обычными функциями, какие ты и раньше писал. Но они могут обращаться к приватным полям.
	~X(); // деструктор. Вызывается при удалении объекта, например, при выходе его из области видимости. Подробнее - в методе.
};

class Y // Теперь опишем класс У
{
private:
	double z;
public: 
	Y(double); // опять же, конструктор
	friend void run(X*, Y*); // функция run будет также дружественной и для У
	~Y(); // деструктор У
};

X::X(double x, double y) // Теперь опишем конструктор. В него будем передавать два числа
{
	this->x = x; // а конструктор положит их в наши поля
	this->y = y; 
}

X::~X() // !!! PAY ATTENTION !!!
        // !!!    ВНИМАНИЕ   !!!
{
	/*
		Since I have nothing to destroy in destructor, 
		I have no idea what to write here, so there's 
		just printing information to know when destructor
		is called. If you have some other ideas about this function,
		just replace the cout or share your ideas with me (https://t.me/Kickoman)

		(Similarly with the destructor of Y class -- ~Y())
	*/

	/*
		Так как мне нечего удалять в деструкторе,
		не имею понятия, что писать здесь, поэтому
		я просто выведу информацию, чтобы знать, когда деструктор
		вызывается. Если у тебя есть какие-то другие идеи насчёт этой функции,
		просто замени cout или поделись ими со мной в телеге.

		(То же самое с деструктором класса У)
	*/
	cout << "X has been destroyed.\n";
}

Y::Y(double z) // Конструктор У
{
	this->z = z; // То же самое, что и с Х
}

Y::~Y() // Деструктор У
{
	cout << "Y has been destroyed.\n";
}

void run(X* xclass, Y* yclass) // наша функция, которая дружественна обоим классам
{
	double x = xclass->x,
		   y = xclass->y,
		   z = yclass->z; // чтобы не писать каждый раз обращение к объекту, я создам тут переменные

	double numerator = exp(abs(x - y)) * pow(abs(x - y), x + y); // то же самое, что и во второй лабе
	double denominator = atan(x) + atan(z);
	double radical = cbrt(pow(x, 6) + pow(log(y), 2));
	xclass->result = numerator / denominator + radical; // забиваю результат в переменную в классе Х
}

void print(X* xclass) // функция вывода ответа из класса Х
{                     // опять же, она не является методом Х, она ему лишь дружественная
	cout << "phi = " << xclass->result << endl;
}

int main()
{
	X *x = new X(-2.235 * 0.01, 2.23); // создаю указатели на классы, выделяю память, вызываются конструкторы, всё как положено
	Y *y = new Y(15.221);
	run(x, y); // передаю сюда указатели на объекты классов
	print(x);
	system("pause");
	return 0;
}